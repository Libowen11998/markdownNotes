一,访问修饰符

**1. public 公共的**

public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。可能只会在其他任何类或包中引用 public 类、方法或字段。

**2. protected 受保护的**

protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。

**3. private 私有的**

private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。只能在声明 private类(不可用于普通类，只用于内部类)、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的，不能直接使用。

二、类、方法和变量修饰符

**1. abstract 声明抽象**

abstract关键字可以修改类或方法。abstract类可以扩展（增加子类），但不能直接实例化。abstract方法不在声明它的类中实现，但必须在某个子类中重写(除非子类也abstract类)。采用abstract方法的类本来就是抽象类，并且必须声明为abstract。

**2：final**

  用途：可以用于声明**成员变量、方法、类以及静态变量**。final声明的内容不允许被更改。

​    1）final类：用final去修饰一个类的时候，表示这个类不能被继承，因此就不存在被子类修改的可能了。

​    2）final方法：父类中定义的被final修饰的方法，不能在子类中被重写。

​    3）final变量：必须要在声明的同时赋予初始值；并且之后不允许更改变量的值（如果修饰的成员变量是基本类型，则表示这个变量的值不能改变；如果修饰的成员变量是一个引用类型，则是说这个引用类型变量所保存的地址不能变，但是这个引用所指向的对象里面的内容还是可以改变的。）

**3：static  静态**

  用途：static的主要作用在于创建独立于具体对象的域变量或者方法。

  用法：作为关键字用于变量声明、方法定义、代码块前修饰。

  特点：

  1）static可以修饰变量、方法、代码块

  2）被static修饰的内容是独立于该类的任何对象的，不属于任何一个实例对象，而是被类的实例对象所共享

  3）在类被加载的时候，就会自动去加载被static修饰的部分

  4）当一个类加载完毕之后，即便没有创建对象，也可以去访问静态内容

  注意事项：

  1）静态方法中没有this关键字，因为静态是随着类的加载而加载，而this是随着对象的创建而存在的。

  2）静态比对象优先存在，因此静态可以访问静态的内容，但是静态不能访问非静态的内容。

  3）非静态的可以去访问静态的内容，因为静态的内容已存在。

1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。



**4：volatile**

  用途：volatile只能修饰变量。该变量**对于所有线程可见，**所有作用在该变量上的操作引起变量的值的变化都会第一时间通知到所有使用它的线程。

  原理：每个线程在使用volatile变量时，如果对变量的值作出了改变，则CPU强制线程立刻把新的值写入主存中。而其他线程在使用到这个变量时，不是从缓存中读取过期值而是直接从主存中读取最新值。

  用法：修饰成员变量。

**5：synchronized**

  用途：可以把任何一个非null 对象 作为"锁"，当synchronized作用在方法上时，锁住的便是对象实例（this）；当作用在静态方法时锁住的便是对象对应的Class实例，因为 Class数据存在于永久带，因此静态方法锁相当于该类的一个全局锁；当synchronized作用于某一代码域时，锁住的便是对应的代码块。

  原理：syncrhoized实现时使用了自旋锁，当一个线程进入竞争队列前，先自旋（等一等看锁会不会释放，一旦释放立刻获得锁对象），自旋期间线程可以做一些无意义的操作来实现暂时占用CPU而不是阻塞。线程自旋超过一定时间还没获得锁，就进入竞争队列被筛选。

  用法：修饰 方法、代码块。



## ● 请你谈谈关于Synchronized和lock 

### 参考回答：

synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。

Lock是一个接口，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。



## ● 请你介绍一下volatile？

### 参考回答：

volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before规则，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。

