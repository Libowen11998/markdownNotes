### [2.4.2. 说一下Java对象的创建过程](https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-4jvm?id=_242-说一下java对象的创建过程)

下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。

![img](https://images.xiaozhuanlan.com/photo/2019/73f30855e4cdfd6f2e944398e97981a2.png)

#### [2.4.2.1. Step1:类加载检查](https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-4jvm?id=_2421-step1类加载检查)

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### [2.4.2.2. Step2:分配内存](https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-4jvm?id=_2422-step2分配内存)

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式：（补充内容，需要掌握）**

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

![img](https://images.xiaozhuanlan.com/photo/2019/3af6db384fba7d42e2f9a07fb57b72d8.)

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### [2.4.2.3. Step3:初始化零值](https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-4jvm?id=_2423-step3初始化零值)

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### [2.4.2.4. Step4:设置对象头](https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-4jvm?id=_2424-step4设置对象头)

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### [2.4.2.5. Step5:执行 init 方法](https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-4jvm?id=_2425-step5执行-init-方法)

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。







### java对象内存布局

HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：**对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。**

<img src="https://img2020.cnblogs.com/blog/1162587/202009/1162587-20200917170544775-1625770619.png" alt="img" style="zoom: 50%;" />

### 对象头(Header)

如果对象是数组类型，则JVM用3个字存储对象头；否则，使用2个字

| 长度     | 内容                   | 说明                             |
| -------- | ---------------------- | -------------------------------- |
| 32/64bit | mark word              | 存储对象的hashCode或者锁信息     |
| 32/64bit | Class metadata address | 存储对象描述数据的指针           |
| 32/64bit | Array length           | 数组的长度（如果当前对象为数组） |

HotSpot JVM的对象头包括二/三部分信息

- 第一部分用于存储**对象自身的运行时数据**，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。
- 另一部分是**类型指针**，即是**对象指向它的类的元数据**的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，即查找对象的元数据信息并不一定要经过对象本身。
- 另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可**以通过普通Java对象的元数据信息确定Java对象的大小**，但是**从数组的元数据中无法确定数组的大小**。

Java对象头的Mark Word里默认存储对象的HashCode、分代年龄和锁标志位，以下图32位机型为例

![img](https:////upload-images.jianshu.io/upload_images/10154499-1192eff42249e57f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/999/format/webp)

在 32 位的 HotSpot 虚拟机中，如果对象处于未被锁定的状态下，那么 Mark Word 的 32bit 空间中的 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，如下表所示：

![img](https://images2015.cnblogs.com/blog/731716/201703/731716-20170302152004001-388228627.png)





## 实例数据（Instance Data） 

实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响。

## 对齐填充（Padding）

对齐填充不是必然存在的，没有特别的含义，它仅起到占位符的作用。

由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，也就是说对象的大小必须是 8 字节的整数倍。对象头部分是 8 字节的倍数，所以当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

## 估算对象大小

### Object obj=new Object()占用字节

这是网上很多人都会提到的一个问题，那么结合上面的Java内存布局，我们来分析下，以64位操作系统为例，new Object()占用大小分为两种情况：

- 未开启指针压缩     占用大小为：**8(Mark Word)+8(Class Pointer)=16字节**
- 开启了指针压缩(默认是开启的)     开启指针压缩后，Class Pointer会被压缩为4字节，最终大小为：**8(Mark Word)+4(Class Pointer)+4(对齐填充)=16字节**

