### mysql 插入数据后返回自增 ID 的七种方法

Mybatis中的属性:使用<insert> 中的useGeneratedKeys 和 keyProperty 两个属性

```xml
<insert id="insert" parameterType="Spares" useGeneratedKeys="true" keyProperty="id">    
        insert into system(name) values(#{name})    
</insert> 
```

```java
int count = systemService.insert(systemBean);   
//运行service层 --> mapper层 把systemBean加入数据库之后,自身就会拥有id字段,使用get()方法就可以获取到
        
int id = systemBean.getId(); //获取到的即为新插入记录的ID 
```





### 如何防止sql注入

通过**PreparedStatement**防止SQL Injection

```java
   sql = "select * from users where NAME = ? and PWD = ?";
   System.out.println(sql);

   con = DBUtility.getConnection();

   //通过Statement 的改为prepareStatement
   stmt = con.prepareStatement(sql);

//   rs = stmt.executeQuery(sql);

    stmt.setString(1, username);
    stmt.setString(2, password);
    rs = stmt.executeQuery();
```





# 为什么mysql索引用B+树而不用哈希表？

Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B+Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B+Tree 索引。

可能很多人又有疑问了，既然 Hash 索引的效率要比 B+Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B+ree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。

1. Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询。
   由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。
2. Hash 索引无法被用来避免数据的排序操作。
   由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；
3. Hash 索引不能利用部分索引键查询。
   对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
4. Hash 索引在任何时候都不能避免表扫描。
   前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
5. Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B+Tree索引高。
   对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下

简单地说，哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

B+树索引和哈希索引的明显区别是：

1. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
2. 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
3. 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
4. 哈希索引也不支持多列联合索引的最左匹配规则；
5. B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。







作者：java-zws
链接：https://www.nowcoder.com/discuss/587994?channel=666&source_id=feed_index_nctrack
来源：牛客网

1.索引 

 1.**B+Tree**:索引底层是用的B+tree数据结构，这种结构可以大幅度提升查询性能，因为B+tree底层是由叶子节点组成的单向列表，塑造出它的稳定性,尤其是范围内的数据检索。b树遍历需要繁琐的中序遍历，b+s树就不需要，直接读取单[链表]()就可以获取到范围内数据，由于B+tree相比较于B树，其树的的高度会相比较低,所以在遍历时会少很多遍历的时间,在时间复杂度上就已经很低。所以B+tree是目前为止性能最高的索引结构。索引之所快也就是将传统的顺序遍历改为[二分查找]()，可以使得要遍历的次数很大程度上减少。 

 2.**Mysql索引**:B+tree索引是目前大多数Mysql默认索引方式，索引又分为聚簇索引和非聚簇索引。聚簇索引是一个记录着数据的索引节点，非聚簇索引是存着主键id，再由id去寻找真实数据。 

 哈希索引：哈希索引是查找速度极快的一种索引，其时间复杂度能到O(1),但是由于是hash策略实现。所以不支持[排序]()和分组，只支持精确查找，不支持范围查找和范围查找。 

 全文索引:innodb不支持全文索引，MyISAM支持全文索引，记录着关键字到文献的映射。 

 空间数据索引：支持空间维度上的索引机制,GIS相关。 

 3.**索引优化** 

 1.索引的优化实质上就是尽可能的利用到索引，索引在查询过程中既不能是函数一部分也不能是表达式一部分，不然会导致索引失效的问题。 

 2.尽可能的使用多列索引，多列索引会让限制条件更加严格，让索引发挥更大的作用。 

 3.索引列的顺序有时候也会影响查询效率。 

 4.对于Blob，text，varchar类型的数据使用前缀索引再好不过，可以只索引前部分的数据，可以节省时间。 

 5.覆盖索引 

 4.**索引的优点** 

 1.索引会让我们查询次数降低，实质层面上也就减少了IO操作，因为IO操作相当费时； 

 2.帮助服务器避免分组和[排序]()，因为索引在数据结构层面上，已经有[排序]()和分组的特征。 

 3.稳定性，将随机性的IO变成顺序性的IO,B+Tree索引会将相邻的数据节点放在一起。 

 5.**索引的适合范围** 

 1.索引在小数据量的数据库中，发挥的作用并不大，因为创建索引也是一定程度上增加了空间复杂度，大部分建立全表扫描要比建立索引更加高效。 

 2.在中型数据量的数据库上可以加索引，因为这个可以大幅度提升数据的查询效率。 

 3.大型数据量的数据库上，不仅需要索引，也可以考虑建立分库分表技术来缓解数据库的压力。 

 **6.查询的优化** 

 1.对于大查询可以将大查询分割成一个个小查询，有效减少服务器的压力。 

 2.分解大连接查询 

 **三.存储引擎** 

 目前mysql两个存储引擎分别为 innodb和myisam引擎；从几个维度来对这两个存储引擎进行比对。 

 事务:前者支持事务，后者不支持事务 

 外键:前者支持外键，后者不支持外键 

 热备份:前者支持热备份，后者不支持热备份 

 安全性:前者课恢复性更高，后者崩溃可恢复性比较低。 

 并发:MyIsam支持表级锁，Innodb还支持行级锁。 

 其他:MyIsam支持空间索引和压缩表。



